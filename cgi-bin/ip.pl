#!/usr/bin/perl
use CGI::Carp qw( fatalsToBrowser );
use Net::SMTP;
use warnings;
use strict;
#
#   hello.pl-- standard "hello, world" program to demonstrate basic
#       CGI programming, and the use of the &getcgivars() routine.
#
# First, get the CGI variables into a list of strings
my %cgivars= &getcgivars ;

# Print the CGI response header, required for all HTML output
# Note the extra \n, to send the blank line
print "Content-type: text/html\n\n" ;


#http://stackoverflow.com/questions/753346/how-do-i-set-the-timezone-for-perls-localtime
use POSIX qw(tzset);
$ENV{TZ} = 'Europe/Zurich';
tzset;

# cgivars in Textfile sichern
my $zeit=localtime();
print $zeit;

open (LOGFILE, ">>../Data/Log.txt") || die "Logfile A nicht gefunden\n";
print (LOGFILE "ip Start \n");
#print LOGFILE "ip Start Datumstring: $Datumstring\n";
close(LOGFILE);

open(HOMEDATEI, "<../Data/ip.txt") or die "HOMEDATEI  diesmal nicht gefunden\n";
print "\n";
#$teststring = "Start $zeit ";
my $ipstring = $cgivars{'ip'};
print  "<p>**$ipstring*<br>";


my $filename = '../Data/Log.txt';
open(my $fh, '<', $filename) or die "Could not open file '$filename' $!";
print "*<$fh>* My first report generated by perl\n";
close $fh;

# 
open my $fhh, ">>", '../Data/Log.txt' 
  or die "Can't open the fscking file: $!";

my $need_work = 2;
my $i_tried   = 0;

while ( $need_work > $i_tried ) {

    $i_tried++;

    my $statement 
        = "I've tried $i_tried things as a test\n";

    print $fhh $statement;
}
close $fhh;

#

if (length($ipstring))
{
	print HOMEDATEI $ipstring;
}
else
{
	my $title='*IP Alarm';
	my $to='r.heimlicher@bluewin.ch';
	my $from= 'ruediheimlicher@ruediheimlicher.ch';
	my $subject='Mail von HomeServer';

	my $mailzeile="Neue IP\n";


	open(MAIL, "|/usr/sbin/sendmail -t");

	## Mail Header
	print MAIL "To: $to\n";
	print MAIL "From: $from\n";
	print MAIL "Subject: $subject\n\n";
	## Mail Body
	print MAIL "Meldung von ip:\n $mailzeile";

	close(MAIL);

	print "<html><head><title>$title</title>
	</head>\n<body>\n\n";

	## HTML content let use know we sent an email
	print "<h1>$title</h1>\n";
	print "<p>Eine Meldung wurde von $from an $to geschickt: <br>Neue IP";
	print "\n\n</body></html>";

}

#foreach (keys %cgivars) 
#{
#    print HOMEDATEI "[$_] = [$cgivars{$_}]\n" ;
#}

close(HOMEDATEI);

# Finally, print out the complete HTML response page
# print <<EOF druckt alles bis EOF


# Print the CGI variables sent by the user.
# Note that the order of variables is unpredictable.
# Also note this simple example assumes all input fields had unique names,
#   though the &getcgivars() routine correctly handles similarly named
#   fields-- it delimits the multiple values with the \0 character, within 
#   $cgivars{$_}.
foreach (keys %cgivars) 
{
    print "<li>[$_] = [$cgivars{$_}]\n" ;
}

# Print close of HTML file
print <<EOF ;
</ul>
</body>
</html>
EOF

exit ;


#----------------- start of &getcgivars() module ----------------------

# Read all CGI vars into an associative array.
# If multiple input fields have the same name, they are concatenated into
#   one array element and delimited with the \0 character (which fails if
#   the input has any \0 characters, very unlikely but conceivably possible).
# Currently only supports Content-Type of application/x-www-form-urlencoded.
sub getcgivars {
    my ($in, %in) ;
    my ($name, $value) ;


    # First, read entire string of CGI vars into $in
    if (defined($ENV{'REQUEST_METHOD'}) && ( ($ENV{'REQUEST_METHOD'} eq 'GET') ||
         ($ENV{'REQUEST_METHOD'} eq 'HEAD') ) )
         {
         if (defined($ENV{'QUERY_STRING'}))
         {
        	$in= $ENV{'QUERY_STRING'} ;
        }

    	} 
    elsif (defined($ENV{'REQUEST_METHOD'}) &&($ENV{'REQUEST_METHOD'} eq 'POST') )
    {
        if ($ENV{'CONTENT_TYPE'}=~ m#^application/x-www-form-urlencoded$#i) 
        {
            length($ENV{'CONTENT_LENGTH'})
                || &HTMLdie("No Content-Length sent with the POST request.") ;
            read(STDIN, $in, $ENV{'CONTENT_LENGTH'}) ;

        } 
        else 
        { 
            &HTMLdie("Unsupported Content-Type: $ENV{'CONTENT_TYPE'}") ;
        }

    } else {
        &HTMLdie("Script was called with unsupported REQUEST_METHOD.") ;
    }
    
    # Resolve and unencode name/value pairs into %in
    foreach (split(/[&;]/, $in)) {
        s/\+/ /g ;
        ($name, $value)= split('=', $_, 2) ;
        $name=~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/ge ;
        $value=~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/ge ;
        $in{$name}.= "\0" if defined($in{$name}) ;  # concatenate multiple vars
        $in{$name}.= $value ;
    }

    return %in ;

}


# Die, outputting HTML error page
# If no $title, use a default title
sub HTMLdie 
{
	
    my $msg = @_ ;
    my $dietitle = @_ ;
    $dietitle= "CGI Error" if $dietitle eq '' ;
    
    print <<EOF ;
Content-type: text/html

<html>
<head>
<title>$dietitle</title>
</head>
<body>
<h1>$dietitle</h1>
<h3>$msg</h3>
</body>
</html>
EOF

    exit ;
}
